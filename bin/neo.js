#!/usr/bin/env node

var require$$0$1=require("path"),require$$1=require("fs"),require$$0=require("perf_hooks"),require$$3=require("child_process");function commonjsRequire(e){throw new Error('Could not dynamically require "'+e+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var $bin={},main={},utils={},benchmarks={};const performance=require$$0["performance"],benchStore=Object.setPrototypeOf({},{toString(){return Object.entries(this).map(([e,t])=>"object"==typeof t?`- [90m${e}: [32m${t.count} times (${t.time.toFixed(3)} ms)[0m`:"").join("\n")}});function benchmarkFunc$1(e,...t){var n=performance.now(),t=e(...t);return _commitMark$(n,e.name||e.toString()),t}function _commitMark$(e,t){benchStore[t]?(benchStore[t].time+=performance.now()-e,benchStore[t].count++):benchStore[t]={time:performance.now()-e,count:1}}benchmarks.benchmarkFunc=benchmarkFunc$1,benchmarks.benchStore=benchStore,benchmarks.commitMark$=_commitMark$;const path$2=require$$0$1,fs$2=require$$1,benchmarkFunc=benchmarks["benchmarkFunc"];function deepMergeMap$1(e,t,n){const{outsideMapInfo:a,outsideMapping:r}=t,{sourcesContent:o,files:s}=e;t=e.mapping.map(n=>n&&n.length?(n.forEach((e,t)=>{n[t][1]<s.length-1&&(n[t][1]+=a.sources.length)}),n):[]).map((o,e)=>{return o&&o.length?(o||[]).map((e,t,n)=>{t=r[o[t][2]];return t&&t.length?t[0]:e[1]>a.sources.length-1?e:null}).filter(e=>e):[]});return a.sources=a.sources.concat(s.slice(0,-1)),a.sourcesContent=a.sourcesContent.concat((o||[]).slice(0,-1)),n&&(a.mappings=n(t)),{mergedMap:t,outsideMapInfo:a}}function mergeFlatMaps$1(e,t,n){var o,a,r,{mapStartToken:n,pluginMapping:s,decode:i}=n||{},s=(s?o=s:[o,a,r]=extractEmbedMap$1(e,{sourceMapToken:n,decode:i}),o.map(e=>e?e[0]:[]).map(e=>t[e[2]]));return[r||e,s]}function extractEmbedMap$1(e,t){var n=(t||{})["sourceMapToken"],o=e.lastIndexOf(n=n||"//# sourceMappingURL=data:application/json;charset=utf-8;base64,"),n=e.slice(o+n.length),n=JSON.parse(globalThis.document?globalThis.atob(n):Buffer.from(n,"base64").toString());return[t.decode(n.mappings),n,e.slice(0,o)]}function findPackagePath$1(e,t,n){var o=t.split("/");let a=e,r=t;for(let e=0;e<o.length;e++)if(a+="/"+o[e],r=path$2.join(a,"package.json"),n.existsSync(r))return r;return r}function findProjectRoot$1(e,t){if(fs$2.existsSync(path$2.join(e,"package.json")))return n=t.advanced?.nodeModulesDirname||"node_modules",path$2.join(e,n);var n=path$2.dirname(e);if(4<n.length)return findProjectRoot$1(n,t);throw new Error("Project directory and according node_modules folder are not found")}function findMainfile$1(e){var e=JSON.parse(fs$2.readFileSync(e).toString()),t=e.module||e.main;return(t=!t&&e.exports?"string"==typeof e.exports?e.exports:e.exports["."].default:t)||void 0}utils.deepMergeMap=deepMergeMap$1,utils.mergeFlatMaps=mergeFlatMaps$1,utils.extractEmbedMap=extractEmbedMap$1,utils.genfileStoreName=function(e,t){var n=t.match(/^\.?\.\//g),o="",a=(n&&(o="."!==(a=path$2.dirname(t))?path$2.join(e||"",a):e||""),n?path$2.basename(t):t),e=path$2.join(o,a).replace("@","__").replace(/[\/\\]/g,"$").replace(/-/g,"_");return~e.indexOf(".")?e.replace(/\./g,""):e},utils.findPackagePath=findPackagePath$1,utils.findProjectRoot=findProjectRoot$1,utils.findMainfile=findMainfile$1;const extensions=[".js",".ts",""],_dirsCache=(utils.extensions=extensions,utils.fileNameRefine=function(e){for(var t of extensions)if(benchmarkFunc(fs$2.existsSync,e+t)){e+=t;break}return[e,t]},utils.refineExtension=function(e){if(!~extensions.slice(0,-1).indexOf(path$2.extname(e))){var t,n=path$2.basename(e),o=benchmarkFunc(readDir$1,path$2.dirname(e));for(t of extensions)if(~o.indexOf(n+t))return[e+=t,t]}return[e,t]},{});function readDir$1(e){return _dirsCache[e]||(_dirsCache[e]=benchmarkFunc(fs$2.readdirSync,e,{}).filter(e=>!e.endsWith(".map")))}const symlinksCache={};function isSymbolLink$1(t){return symlinksCache[t]||(Object.keys(symlinksCache).filter(e=>t.startsWith(e)).length?symlinksCache[t]:symlinksCache[t]=benchmarkFunc(fs$2.lstatSync,t).isSymbolicLink())}utils.readDir=readDir$1,utils.isSymbolLink=isSymbolLink$1;var declarations$={AbstractImporter:class{dynamicModulesExported=null;get currentFile(){return this.progressFilesStack.at(-1)}progressFilesStack=[];linkedModulePaths=[]}},exports$={},_versions={};_versions.version=Date.now();const statHolder$2={imports:0,requires:0,dynamicImports:0,exports:{cjs:0},get importsAmount(){return this.imports+this.requires}},statHolder$1=(_versions.statHolder=statHolder$2,_versions)["statHolder"];function commonjsExportsApply$1(e,o,{fileStoreName:a,extractinNames:r,globalOptions:s}){let i=!1;return e=e.replace(/^(?: *module\.)?exports(?<export_name>\.[\w\$][\w\d\$]*)?[ ]=\s*(?<exports>[\s\S]+?(?:\n\}|;))/gm,function(e,t,n){if((i=e.startsWith(" "))&&!s.experimental?.withConditions)return s.advanced?.debug&&console.warn(`>> condition export detected for ${a}. May be need specifying withConditions option`),i=!1,e;if(statHolder$1.exports.cjs++,t)if(t=t.slice(1),s.advanced?.treeShake){if(r.has(t))o+=(o&&", ")+t;else if("object"==typeof s.advanced?.treeShake&&!1!==s.advanced?.treeShake.cjs)return""}else o+=(o&&", ")+t;else o+=(o&&", ")+"default: $default",n.match(/^\w+;$/)&&(o+=", "+n.slice(0,-1));return`var ${t||"$default"} = `+n}),{content:e=i?e.replace("typeof module",'"object"'):e,_exports:o}}function defaultExprsRemove(e,t,n){return n?e=e.replace(/(?<=;|\})export( default ([\w\d_\$]+(?:;|\n))?)?(\{[\s\S]+?\})?;?/gm,"").trimEnd():t&&e.match(/^export (default ([\w\d_\$]+(?:;|\n))?)?((\{[^\n]+\}[\n;])|(\{[^\n]+\}$)|(\{[\s\S]+?[\n;]\}))?;?/gm),e}function applyDefaultExports(e,{isbuilt:t,extract:n,_exports:o,globalOptions:a}){t=e.match(t?/(?<=;)export default ((?:\(|\[)?['"\(\)\w_\d\$,\{\}\.]+)\b( [\w_\$]+)?/m:/^export default (?:((?:\(|\[)?['"\(\)\w_\d\$,\{\}\.]+)\b( [\w_\$]+)?((?:\*)? \w+)?)/m);return t?a.advanced?.treeShake&&!n.default&&!~n.names.indexOf("default")||("async"==t[1]&&t[3]?o+=(o&&", ")+"default: "+t[3].replace(/^\* /,""):~["function","class"].indexOf(t[1])?(t[2]||(e=e.replace(/^export default \b([\w_]+)\b/m,"export default $1 $default")),o+=`${o&&", "}default: `+(t[2]||"$default")):("("!=t[1][0]&&"["!=t[1][0]||(e=e.replace(/^export default /m,"const _default = "),t[1]="_default"),o+=(o&&", ")+"default: "+t[1])):e=e.replace(/^export default[ ]+((\{[ \w\d,\(\):;'"\n\[\]]*?\})|(\{[\s\S]*\n\}))/m,function(e,t,n){return`var _default = ${t};
export default _default;`}),{content:e,_exports:o}}exports$.defaultExprsRemove=defaultExprsRemove,exports$.applyDefaultExports=applyDefaultExports,exports$.commonjsExportsApply=commonjsExportsApply$1;var monadutils={};function chainingCall$1(e,t,n){var o;return t?(o=e(...Array.prototype.slice.call(arguments,2)),t-1?chainingCall$1(e,t-1,o):o):n}function conditionalChain$1(e,t,n,o=5){n=e(n);return t(n)?n:o?conditionalChain$1(e,t,n,o-1):null}function releaseProcess$1(e,t){return e.sourceMaps&&console.warn("Generate truth sourcemaps with options `release = true` is not guaranteed"),t=(t=t.replace(/console\.log\([^\n]+?\);/g,"")).replace(/(?<!['"/][^\n]*?)[\t ]*\/\/[\s\S]*?\n/gm,e.sourceMaps?"\n":""),t=e.sourceMaps?t:(t=(t=t.replace(/^([\s]*?\n){3}([\s]*?\n)*/gm,"\n")).replace(/(?<!['"/][^\n]*?)\/\*[\s\S]*?\*\//g,()=>"")).replace(/^[\t ]+\{[\n\r,\w\t ]+\}\r?\n/gm,"")}function cleaningDebugBlocks$1(e){return e.replace(/\/\*\@if_dev ?\*\/[\s\S]*?\/\*\@end_if ?\*\//,"")}monadutils.chainingCall=chainingCall$1,monadutils.conditionalChain=conditionalChain$1;var release$={cleaningDebugBlocks:cleaningDebugBlocks$1,releaseProcess:releaseProcess$1},treeShaking={violentShake:function(e,t,n){return n},theShaker:{globalOptions:null,shakedStore:{},work({extracting:a,exports$:r,content:e,preShakeUp:t,onMiss:n}){var o=this.globalOptions;for(const i of r){var[s,,]=i.split(":").map(e=>e.trim());if(!~a.indexOf(s)){s=new RegExp(`(function) ${i}\\([\\w\\d, \\{\\}\\$]*\\)\\s*\\{[\\s\\S]*?\\n\\}\\r?\\n`,"m"),s=e.match(s)||e.match(new RegExp(`(const|let|var) ${i} = \\([\\w\\d, \\{\\}\\$]*\\) ? =\\> \\{[\\s\\S]*?\\n\\}\\r?\\n`))||e.match(new RegExp(`class ${i}( (?:extends|implements) [\\w\\d\\$_]+,)? ?\\{[\\s\\S]*?\\n\\}\\r?\\n`));if(s){let o=e.replace(s[0],"");if(!o.match(new RegExp(`\\b${i}\\b`))){const l=[i];e=o.replace(/\n?\t?(?<isExported>export (?:default ))?function (?<fname>[\w\d\$_]+)\([\w\d_\$, \{\}]*?\) ?\{[\S\s]*?\n\}/g,(e,t,n)=>{return~a.indexOf(n)||~n.indexOf("$")||o.replace(e,"").match(new RegExp(`\\b${n}\\b`))?e:(~r.indexOf(n)&&l.push(n),`// function "${n}" violently tree shaked `)}),t(l)}}else o.verbose&&o.advanced.debug&&n(i)}}return e}}};const fs$1=require$$1,path$1=require$$0$1,{deepMergeMap,genfileStoreName,findPackagePath,findMainfile,findProjectRoot,fileNameRefine,refineExtension,readDir,isSymbolLink}=utils,AbstractImporter=declarations$["AbstractImporter"],commonjsExportsApply=exports$["commonjsExportsApply"],{chainingCall,conditionalChain}=monadutils,{releaseProcess,cleaningDebugBlocks}=release$,{violentShake:forceTreeShake,theShaker}=treeShaking,{version,statHolder}=_versions,namedImportsExpRegex=/^import ((((?<_D>\w+, )?\{([\w,\s\$]+)\})|([\w, ]+)|(\* as [\w\$]+)) from )?["'](.?.\/)?([@\w\-\/\.]+)["'];?/gm,requireOptions={sameAsImport:"same as import",doNothing:"doesn`t have affect"},fastShaker={};let startWrapLinesOffset=1,endWrapLinesOffset=5;var rootOffset=0,exportedFiles=[];let logLinesOption=!1,incrementalOption=!1,importer=null;function combineContent(e,t,n,o){(globalOptions=n).advanced?.treeShake&&(theShaker.globalOptions=globalOptions),globalOptions.target=n.targetFname;var a=e;return rootOffset=0,sourcemaps.splice(0,sourcemaps.length),Object.keys(modules).forEach(e=>delete modules[e]),logLinesOption=n.logStub,(incrementalOption=!!n.advanced&&n.advanced.incremental)&&(startWrapLinesOffset=3,endWrapLinesOffset=8),exportedFiles=[],n.purgeDebug&&((n.sourceMaps||n.getSourceMap)&&(console.warn("[33mremoveLazy option uncompatible with sourceMap generation now. Therefore it`s passed[0m"),n.sourceMaps=null,n.getSourceMap=null),e=cleaningDebugBlocks(e)),e=importInsert(e,t,n),e=mapGenerate({target:n.targetFname,options:n,originContent:a,content:e}),n.advanced&&n.advanced.ts&&(e=n.advanced.ts(e)),console.log(`
[34mIn total handled ${statHolder.importsAmount} imports[0m`),globalOptions.advanced?.debug&&console.log(`[34m- ${statHolder.exports.cjs} cjs exports is found[0m`),e}function buildFile(e,t,n){var o='File [32m"'+t+'"[33m built in',a=(console.time(o),fs$1.readFileSync(e).toString()),e=path$1.resolve(e);const r=t||path$1.parse(e).dir+path$1.sep+path$1.parse(e).name+".js";t=Object.assign({entryPoint:path$1.basename(e),release:!1,targetFname:r},n);try{var s=fs$1.readdirSync?fs$1.readdirSync(path$1.dirname(t.targetFname)):null}catch(e){console.warn(`Target dir "${t.targetFname}" does not exists. It'll be autocreated.`),fs$1.mkdirSync(path$1.dirname(t.targetFname))}n=combineContent(a,path$1.dirname(e),t);return s&&s.forEach(e=>".js"==path$1.extname(e)&&fs$1.rmSync(path$1.join(path$1.dirname(r),e))),fs$1.writeFileSync(r,n),console.log("[33m"),console.timeEnd(o),console.log("[0m"),n}class PathMan{basePath;importer;linkedModules=[];constructor(e,t){this.dirPath=e,this.getContent=t||getContent}}class Importer extends AbstractImporter{pathMan;constructor(e){super(),this.namedImportsApply=namedImportsApply,this.moduleStamp=moduleSealing,this.pathMan=e,this.isFastShaking="object"==typeof globalOptions.advanced?.treeShake&&"surface"==globalOptions.advanced?.treeShake.method,e.importer=this}attachModule(e,t,{root:n,_needMap:o,extract:a}){this.progressFilesStack.push(e);let r=this.moduleStamp(e,{root:n||void 0,_needMap:o,extract:a});return this.progressFilesStack.pop(),!!r&&(e=r.lines.map(([n,e],t)=>{return t>=r.lines.length-endWrapLinesOffset||t<startWrapLinesOffset?null:1===o?[].map.call(e,(e,t)=>[t,sourcemaps.length-1+1,n-startWrapLinesOffset,t]):[[0,sourcemaps.length-1+1,n-startWrapLinesOffset,1]]}),sourcemaps.push({name:t.replace("$$","@").replace(/(\$|__)/g,"/")+".js",debugInfo:e}),!0)}generateConverter(g,$){const{root:x,_needMap:b,extract:S}=g;return(e,t,n,o,a,r,s,i,l,c,p,d)=>{g.isEsm||(g.isEsm=!0),a&&(s=a.match(/[\w_\d\$]+/)[0]),statHolder.imports+=1;let u=r?.split(",");if(r&&globalOptions.advanced?.treeShake&&S?.names){const h=new Set(S.names);var m=u?.map(e=>e.trim().split(" as "));if(!m.map(e=>e.slice().pop()).filter(t=>{return!!h.has(t)||!!d.slice(p+e.length).match(new RegExp(`\\b${t}\\b`),"")||(u=u.filter(e=>!e.trimEnd().endsWith(t)),m=u?.map(e=>e.trim().split(" as ")),!1)}).length&&globalOptions.advanced?.treeShake)return`// ==> "${c}" has shaken`}a=this.attachFile(c,l,{extract:{names:m?.map(e=>e.slice()[0])||u?.map(e=>e.trim().split(" ")[0]),default:s},root:x,_needMap:b});if(s&&$(s))return`const { default: ${s} } = $${a.replace("@","_")}Exports;`;if(!s){if(i)return`const ${i.split(" ").pop()} = $${a.replace("@","_")}Exports;`;var f,r=u.map(e=>{var t;return~e.indexOf(" as ")?((t=e.trim().split(" "))[0]+": "+t.pop()).trim():e});for(f of r)~f.indexOf(":")&&(f=f.split(": ").pop()),$(f);return`const { ${r.join(", ")} } = $${a.replace("@","_")}Exports`}l=new Error(`Variable '${s}' is duplicated by import './${c}.js'`);l.name="DublicateError",console.log("[31m%s[0m",`Detected ${l.name} during build process: `+l.message,"[0m"),console.log("Fix the errors and restart the build."),process.exit(1)}}attachFile(n,o,{root:a,_needMap:r,extract:t}){var e,s=path$1.extname(n)?n.slice(0,-path$1.extname(n).length):n;const i=genfileStoreName(!o||nodeModules[n]?void 0:a,(o||"")+s),l=this;return modules[i]?i in theShaker.shakedStore?(e=(s=theShaker.shakedStore[i]).shaked.filter(e=>~t?.names.indexOf(e))).length&&c({default:t.default,names:e.concat(s.extracted)}):globalOptions.advanced.treeShake&&(e=t?.names?.filter(e=>new Set(fastShaker[i]).has(e)))?.length&&(modules[i]=modules[i].replace(/exports = \{([\w\d_\$, :]+?)\}/,`exports = { ${e},$1}`)):c(t),i;function c(e){var t;o?l.attachModule((o||"")+n,i,{root:a,_needMap:r,extract:e}):l.pathMan.getContent==getContent&&(nodeModulesPath=nodeModulesPath||findProjectRoot(l.pathMan.dirPath,globalOptions),fs$1.existsSync(nodeModulesPath)?(t=path$1.normalize(n),t=l.getMainFile(t),nodeModules[n]=t,l.attachModule(n,i,{root:n+"/"+path$1.dirname(t),_needMap:r,extract:e})):console.warn("node_modules doesn`t exists. Use $onModuleNotFound method to autoinstall"))}}getMainFile(e){var t=path$1.join(nodeModulesPath,e),t=path$1.join(t,"package.json");let n="";if(fs$1.existsSync(t))n=findMainfile(t);else if(!path$1.extname(e)){var t=e.split(/[\/\\]/),o=path$1.join(nodeModulesPath,t[0],"package.json");if(fs$1.existsSync(o))return o=fs$1.readFileSync(o).toString(),(o=JSON.parse(o)).exports?((o=o.exports["./"+e.split(/[\/\\]/).slice(1).join("/")]).import||o.default||o.require||o).replace("./"+t.slice(1).join("/"),"."):""}return n}genChunkName(e){return"$_"+path$1.basename(e)+"_"+version+".js"}extractLinkTarget(e,t){return fs$1.lstatSync(path$1.join(nodeModulesPath,e)).isSymbolicLink()&&(e=path$1.relative(nodeModulesPath,fs$1.readlinkSync(path$1.join(nodeModulesPath,e))),console.log(e),t=path$1.join(e,t)),t}joinAllContents(e,t){return e="\n\n//@modules:\n\n\n"+Object.values(modules).filter(Boolean).join("\n\n")+`


//@${t.entryPoint}: 
`+e}}function mapGenerate({options:e,content:n,originContent:o,target:a,cachedMap:r}){let s=!1;if(e.getSourceMap||e.sourceMaps){var i=Object.values(modules).filter(Boolean),l=r||sourcemaps.map(e=>e.debugInfo).reduce((e,t)=>e.concat(t));if(r||l.push(null),e.getSourceMap&&e.getSourceMap({mapping:l,sourcesContent:i.map(e=>e.split("\n").slice(startWrapLinesOffset,-endWrapLinesOffset).join("\n")).concat([o]),files:sourcemaps.map(e=>e.name)}),e.sourceMaps){let t=l.map(e=>e||[]);e.sourceMaps.shift&&(t=Array(e.sourceMaps.shift).fill([]).concat(t));var r=e.sourceMaps.encode(t),l=path$1&&a?path$1.basename(a):"";const c={version:3,file:l,sources:sourcemaps.map(e=>e.name),sourcesContent:i.map(e=>e.split("\n").slice(startWrapLinesOffset,-endWrapLinesOffset).join("\n")).concat([o]),names:[],mappings:r};e.sourceMaps.injectTo&&(i=e.sourceMaps.injectTo,{mergedMap:o,outsideMapInfo:r}=deepMergeMap({...c,files:c.sources,mapping:t},{outsideMapInfo:i,outsideMapping:i.maps||globalOptions.sourceMaps.decode(i.mappings)}),r.mappings=e.sourceMaps.encode(t=o),c.sources=r.sources,c.sourcesContent=r.sourcesContent),e.plugins&&(s=!0,e.plugins.forEach(e=>{e.bundle&&(n=e.bundle(n,{target:a,maps:c,rawMap:t}))})),e.sourceMaps.verbose&&console.log(c.sources,c.sourcesContent,t),fs$1&&!0===e.sourceMaps.external?(fs$1.writeFileSync(a+".map",JSON.stringify(c)),n+=`
//# sourceMappingURL=${l}.map`):(i=globalThis.document?btoa(JSON.stringify(c)):Buffer.from(JSON.stringify(c)).toString("base64"),n+=`
//# sourceMappingURL=data:application/json;charset=utf-8;base64,`+i)}}return e.plugins&&!s&&e.plugins.forEach(e=>{e.bundle&&(n=e.bundle(n,{target:a}))}),n}let globalOptions=null,nodeModulesPath=null;const nodeModules={};function importInsert(e,t,n){var t=new PathMan(t,n.getContent||getContent),o=!(!n.sourceMaps&&!n.getSourceMap);logLinesOption&&(e=e.replace(/console.log\(/g,function(){var e=arguments[2].slice(0,arguments[1]).split("\n").length.toString();return'console.log("'+n.entryPoint+":"+e+':", '}));const a=n.sourceMaps&&n.sourceMaps.charByChar,r=(e=(importer=new Importer(t)).namedImportsApply(e,{root:void 0,_needMap:n.sourceMaps&&n.sourceMaps.charByChar?1:o,extract:null}),e=importer.joinAllContents(e,n),null);return o&&(rootOffset+=5+2*sourcemaps.length+1,sourcemaps[0]&&sourcemaps[0].debugInfo.unshift(r,r,r,r),sourcemaps.forEach(e=>{e.debugInfo.unshift(r)}),t=e.split("\n").slice(rootOffset).map((e,n)=>{return a?[[0,sourcemaps.length,n,0]]:[].map.call(e,(e,t)=>[t,sourcemaps.length,n,t])}),sourcemaps.push({name:n.entryPoint,debugInfo:[r,r,r].concat(t)})),e=n&&n.release?releaseProcess(n,e):e}const modules={},sourcemaps=[];function namedImportsApply(e,i){const{root:c,_needMap:p}=i,t=(i.isEsm=!1,new Set);var n=this.generateConverter(i,function(e){return t.has(e)?(globalOptions.advanced?.debug&&console.warn(`Duplicating the imported name: "${e}"`),!1):(t.add(e),!0)}),e=e.replace(namedImportsExpRegex,n),n=globalOptions.advanced?.optimizations?.ignoreDynamicImports?e:e.replace(/(?<!\/\/[^\n]*)import\(['"`](\.?\.\/)?([\-\w\d\.\$\/@\}\{]+)['"`]\)/g,function(e,t,n,o){if(globalOptions.advanced.dynamicImports?.foreignBuilder)return r=t?path$1.join(c,n):path$1.join(nodeModulesPath=nodeModulesPath||findProjectRoot(this.pathMan.dirPath,globalOptions)+"/",n),globalOptions.advanced.dynamicImports?.foreignBuilder(r);const a=n.match(/^([\s\S]+\/)?([\w\d_\-\$]+)?\$\{([\w\d_\$]+)\}([\w\d_\-\$\.]+)?(\/[\s\S]+)?$/);if(!a)return s.call(importer,t,n);if(a.input.length,a.index,a[0].length,1<(a[2]||a[4])?.length||t){var r=fs$1.readdirSync(t?c:(nodeModulesPath=findProjectRoot(this.pathMan.dirPath,globalOptions)+"/")+a[1]||"").filter(e=>e.startsWith(a[2]||"")&&e.startsWith(a[4]||""));if(r.length)return 10<r.length&&console.warn(`Too many files have found for dynamic import matching "${n}" (inside "${this.currentFile}")`),r.map(e=>(a[1]||"")+e+(a[4]||"")).forEach(e=>{s.call(importer,t,e)}),`fetch(\`${"./"+(globalOptions.advanced?.dynamicImportsRoot??path$1.basename(path$1.dirname(globalOptions.target))+"/")+this.genChunkName(n)}\`)`+".then(r => r.text()).then(content => new Function(content)())";console.warn(`No files matching the pattern "${n}" could be found for dynamic import during process of "${this.currentFile}"`)}}.bind(this));return globalOptions?.advanced?.requireExpression!==requireOptions.sameAsImport||i.isEsm?n||e:(n||e).replace(/(const|var|let) ((?<varnames>\{?[\w, ]+\}?) = require\(['"](?<filename>[\w\.\/]+)['"]\)[,\n\s]*)+(?=;|\n)/g,(e,t,n,o,a,r,s)=>(statHolder.requires+=1,e=e.replace(/(?:(const|var|let) )?(?<varnames>\{?[\w, ]+\}?) = require\(['"](?<filename>[\w\.-\/]+)['"]\)/g,(e,t,n,o)=>{var a=genfileStoreName(c,o);return!modules[a]&&(this.attachModule(o,a,i),modules[a])?`${t||""} ${n} = $${a}Exports`:e.split("=")[0]+`= $${a.replace("@","_")}Exports`})));function s(n,o){var a=""+(n||"")+o;if(statHolder.dynamicImports+=1,fs$1.writeFileSync){var n=a+(!path$1.extname(a)&&n?globalOptions.advanced.ts?".ts":".js":""),r=this.genChunkName(o),o=path$1.dirname(globalOptions.target);const i=new Set(Object.keys(modules).filter(e=>modules[e]));this.dynamicModulesExported=[];var s=this.moduleStamp(n,{root:c,_needMap:p,extract:void 0})?.fileStoreName||genfileStoreName(c,a),n=modules[s];let e="";for(const l of Object.keys(modules).filter(e=>!i.has(e)))l!=s&&(e+=modules[l]+"\n",modules[l]=void 0);i.has(s)?console.warn(`It seems you import "${a}" dynamiccally, which one has imported before`):modules[s]=void 0,this.dynamicModulesExported=null;let t=e+"\n{\n"+n.split("\n").slice(1,-1).join("\n")+"\n}";globalOptions.release&&(t=releaseProcess(globalOptions,t)),fs$1.writeFileSync(path$1.join(o,r),t),r="./"+(globalOptions.advanced?.dynamicImportsRoot||"")+r}return`fetch("${r||a}")`+".then(r => r.text()).then(content => new Function(content)())"}}function moduleSealing(t,{root:e,_needMap:n,extract:o}){let a=null,r=this,s=this.pathMan.getContent(t.startsWith(".")&&e?(e.startsWith(".")?"./":"")+path$1.join(e,t):t,t.startsWith(".")&&nodeModules[e]?path$1.join(nodeModulesPath,e,path$1.dirname(nodeModules[e]),t):void 0,e=>{a=t=e},{linkPath:this.linkedModulePaths.slice(-1)[0],onSymLink(e){e=conditionalChain(path$1.dirname,e=>"node_modules"==path$1.basename(e),e);r.linkedModulePaths.push(e)}});var i=nodeModules[t]?void 0:e,i=(t.startsWith(".")&&nodeModules[t],genfileStoreName(t.startsWith(".")?i:void 0,a?path$1.dirname(t):path$1.extname(t)?t.slice(0,-path$1.extname(t).length):t));if(void 0===s){var l=new Error(`File "${(e?e+"/":"")+t}.js" doesn't found`);if(l.name="FileNotFound",!n||globalOptions.onError&&globalOptions.onError(l))return null;throw l}if(""==s){if(!theShaker.shakedStore[i])return null;s=(this.dynamicModulesExported,theShaker.shakedStore[i].content)}({reExports:l,content:s}=reExportsApply(s,o,e,n));let c;({_exports:c,content:s}=exportsApply(s,l,o,{fileStoreName:i,getOriginContent:()=>s}));var l=globalOptions.advanced?.treeShake;if(!c&&l){if("object"!=typeof l||!l.exclude?.has(i))return o?.names?.length&&globalOptions.advanced?.debug&&console.warn(`Something went wrong for ${i}: extracting extports (${o.names}) does not found`),modules[i]="",null;c||(console.warn(`for '${i.split("$").pop()}' module the exports were replaced to globalThis cause of is empty`),c="window")}else{l=t.startsWith(".")?path$1.dirname(t):nodeModules[t]?e||t:path$1.dirname(Object.keys(nodeModules).find(e=>e.startsWith(t))||t),e=(logLinesOption&&(s=s.replace(/console.log\(/g,function(){var e=arguments[2].slice(0,arguments[1]).split("\n").length.toString();return'console.log("'+t+".js:"+e+':", '})),l="."===l?"":l,(e&&void 0===nodeModules[t]&&!a?e+(l?"/":""):"")+l);if(o?.names&&~c.indexOf(":")){const p=c.split(", ").map(e=>e.split(":").map(e=>e.trim()));o.names=o.names.map(t=>(p.find(e=>e[0]==t)||[])[1]||t)}s=this.namedImportsApply(s,{root:e,_needMap:n,extract:o}),this.linkedModulePaths.length&&r.linkedModulePaths.pop()}return c=`exports = { ${c=c.startsWith(" ,")?c.slice(2):c} };`+"\n".repeat(startWrapLinesOffset),s="\t"+s+"\n\n"+c+"\nreturn exports",modules[i]=`const $${i.replace("@","_")}Exports = (function (exports) {
 ${s.split("\n").join("\n\t")} 
})({})`,incrementalOption&&(modules[i]=`
/*start of ${t}*/
${modules[i]}
/*end*/

`),n?(l=modules[i].split("\n"),{fileStoreName:i,updatedRootOffset:rootOffset+=l.length,lines:l.map((e,t)=>[t,e])}):null}function reExportsApply(e,i,l,c){e=e.replace(/^export {[\n\r ]*([\w\d\.\-_\$, \n\/"\r]+)[\n\r ]*} from ['"]([\./\w\d@\$-]+)['"];?/gm,function(e,t,n,o){if("default "==t)return`import {default as __default} from "${n}";
export default __default;`;{const a=t.split(",").map(e=>e.split("\n").pop()).filter(Boolean).map(e=>e.trim()).filter(e=>!e.startsWith("//"));t=a.map((e,t)=>{var n;return~e.indexOf(" as ")?"default"===(n=e.split(" "))[2]?(n[2]="$d_"+o,n[0]="default",a[t]=a[t].replace("default","$d_"+o),n.reverse().join(" ")):n[2]:"default"==e?(a[t]="default as __default","__default as default"):e});return`import { ${a.join(", ")} } from '${n}';
export { ${t.join(", ")} }`}});var p=[];return e=e.replace(/export \* from ["'](.?.\/)?([@\w\-\/\.]+)["'];?/g,(e,t,n,o,a)=>{var r=importer.attachFile(n,t,{root:l,_needMap:c,extract:i}),s=modules[r].match(/exports = \{([\w, :\d_\$]+)\}/);if(s)return s=s[1].split(",").map(e=>e.split(": ")[0].trim()),p=p.concat(s),`const { ${s.join(", ")} } = $${r}Exports`;if(globalOptions.verbose){if(globalOptions.advanced?.treeShake)return console.log(`[32m>> Shaked re-export for "${t||""}${n}"[0m`),"";console.warn(`[31mUnexpected re-export for "${t||""}${n}"[0m`)}return e}),{reExports:p,content:e}}function exportsApply(e,t,s,{fileStoreName:r,getOriginContent:n}){let o=[],i=(e=e.replace(/^export (class|(?:(?:async )?function)|let|const|var) ([\w_\n]+)?[\s]*=?[\s]*/gm,function(e,t,n){return o.push(n),e.slice(7)}),(t||[]).concat(o).join(", "));const l=s?.names&&new Set(s?.names);let c=!1;e=e.replace(/(?:(?:^export )|(?:;|\})export)\{([\s\S]*?)\}/gm,function(e,t,n,o){t=t.trim().split(/,\s*(?:\/\/[^\n]+)?/);let a=t.join(", ");~a.indexOf(" as ")&&(a=a.replace(/([\w\$]+) as ([\w]+)/g,(e,t,n)=>"default"==t?n:n+": "+t));if((c=";"===e[0][0]||"}"===e[0][0])||!globalOptions.advanced?.treeShake||!l)return i+=(i&&", ")+a,c?e[0][0]:"";t=a.split(", ").filter(e=>{var t=l.has(e.split(":")[0]);return t||(fastShaker[r]||(fastShaker[r]=[])).push(e),t});return t.length?i+=(i&&", ")+t.join(", "):globalOptions.advanced.debug&&console.warn("! Exports does not found for "+r),""}),c&&(e=e.replace(/import\{([\w ]+)\}from['"](\w+)['"]/,(e,t,n)=>`const{${t.replace(" as ",":")}}=$${n}Exports`));var p=!1;return e=e.replace(c?/(?<=;)export default ((?:\(|\[)?['"\(\)\w_\d\$,\{\}\.]+)\b( [\w_\$]+)?/m:/^export default (?:((?:\(|\[)?['"\(\)\w_\d\$,\{\}\.]+)\b( [\w_\$]+)?((?:\*)? \w+)?);?/m,function(e,t,n,o,a,r){return p=!0,{iifeExpr:e,_exports:i}=extractDefaultExpr(e,{extract:s,expr:t,exprName:n,isIterator:o},i),e}),p||(e=e.replace(/^export default[ ]+((\{[ \w\d,\(\):;'"\n\[\]]*?\})|(\{[\s\S]*\n\}))/m,function(e,t,n){return i+=(i&&", ")+"default: _default",`var _default = ${t};`})),i||({content:e,_exports:i}=commonjsExportsApply(e,i,{fileStoreName:r,extractinNames:l,globalOptions:globalOptions})),globalOptions.advanced?.treeShake&&!importer.isFastShaking&&l&&i&&!c?({_exports:t,content:e}=shakeBranch({_exports:i,extractinNames:l,content:e,fileStoreName:r,getOriginContent:n}),{_exports:t,content:e}):{_exports:i,content:e}}function extractDefaultExpr(e,{extract:t,expr:n,exprName:o,isIterator:a},r){let s="";return{iifeExpr:s=!globalOptions.advanced?.treeShake||t.default||~t.names?.indexOf("default")?"async"==n&&a?(r+=(r&&", ")+"default: "+a.replace(/^\* /,""),e.slice(15)):~["function","class"].indexOf(n)?o?(r+=`${r&&", "}default: `+o,e.slice(15)):(r+=`${r&&", "}default: $default`,n+" $default"):"("==n[0]||"["==n[0]?(r+=(r&&", ")+"default: _default","const _default = "+n):(r+=(r&&", ")+"default: "+n,e.replace(/^export (default ([\w\d_\$]+(?:;|\n))?)?((\{[^\n]+\}[\n;])|(\{[^\n]+\}$)|(\{[\s\S]+?[\n;]\}))?;?/gm,"")):e.replace(/^export (default ([\w\d_\$]+(?:;|\n))?)?((\{[^\n]+\}[\n;])|(\{[^\n]+\}$)|(\{[\s\S]+?[\n;]\}))?;?/gm,""),_exports:r}}function shakeBranch({_exports:e,extractinNames:t,content:n,fileStoreName:o,getOriginContent:a}){let r=Array.from(t);var s=e.split(",").map(e=>e.split(" as ").pop().trim());return{_exports:e=s.filter(e=>{e=t.has(~e.indexOf(":")?e.split(":").shift():e);return e||!1}).join(", "),content:n=theShaker.work({extracting:r,exports$:s,content:n,preShakeUp(e){theShaker.shakedStore[o]?theShaker.shakedStore[o].shaked.push(...e):theShaker.shakedStore[o]={content:a(),shaked:e,extracted:r}},onMiss(){}})}}function getContent(t,n,e,o){let a=null;var r,s,i=this.importer.dynamicModulesExported,n=n||(t.startsWith(".")?path$1.normalize(this.dirPath+path$1.sep+t):path$1.join(a=path$1.join(o?.linkPath||(nodeModulesPath=nodeModulesPath||findProjectRoot(this.dirPath,globalOptions)),t),nodeModules[t]||""));if(t.startsWith(".")||t in nodeModules||(nodeModules[t]=this.importer.getMainFile(t),n=path$1.join(n,nodeModules[t])),[n,r]=refineExtension(n),path$1.extname(n)||""!==r||(t.startsWith(".")||nodeModules[t]||!o?.linkPath||(s=findMainfile(path$1.join(n,"package.json")),n=path$1.join(n,s)),s)||1!==n.split(path$1.sep).pop().split(".").length||(n+=path$1.sep+"index.js",e&&e(t+"/index.js")),exportedFiles.includes(n))return console.log(`${"."==this.basePath?"dynamically ":""}reimport of '${n}'`),"";(i||exportedFiles).push(n);try{var l,c=fs$1.readFileSync(n).toString();!globalOptions.advanced?.allFilesAre&&a&&isSymbolLink(a)&&(l=fs$1.readlinkSync(a),o?.onSymLink?.call(null,l))}catch(e){if(!~e.message.indexOf("lstat"))return console.warn(`File "${n}" ("import ... from '${t}'") doesn't found`),'console.log("__")'}return c}main.default=main.build=main.buildContent=main.combineContent=combineContent,main.integrate=main.packFile=main.buildFile=buildFile,main.requireOptions=requireOptions;const path=require$$0$1,fs=require$$1,execSync=(require$$0.performance,require$$3)["execSync"],build=main.buildFile,{mergeFlatMaps,extractEmbedMap}=utils,TS_MAP_Token="//# sourceMappingURL=data:application/json;base64,",cache={};function getArgv(e){e=process.argv.indexOf(e)+1;return e?process.argv[e]:null}~process.argv.indexOf("-h")&&(console.log(`
-s 		- source file name (could be passed as first arg without the flag -s)
-t 		- target file name (required)
-m 		- generate sourcemap file 	(optional)
--time 	- verbose build time  		(optional)
    `),process.exit(0));const helpers={s:"source file",t:"target file"};let source=resolveFile("s",1),target=resolveFile("t",!1);const sourcemapInline=~process.argv.indexOf("--inline-m"),sourcemap=sourcemapInline||~process.argv.indexOf("-m"),minify=sourcemapInline||~process.argv.indexOf("--minify"),jsx__converter=sourcemapInline||~process.argv.indexOf("--jsx-converter"),release=~process.argv.indexOf("-r");release&&sourcemap&&console.log("[34m >> using the -k option in conjunction with - is not recommended, since these options have not been tested together.[0m"),console.time("built in");let result=build(source,target,{release:1==!!release,sourceMaps:sourcemap?(()=>{var t="sourcemap-codec";try{var n=commonjsRequire(t)["encode"]}catch(e){console.log("[33mThe package needed to generate the source map has not been found and will be installed automatically[0m"),console.log(execSync("npm i sourcemap-codec").toString());var n=commonjsRequire(t)["encode"]}return{encode:n,external:1==!!sourcemapInline}})():null,advanced:source.endsWith(".ts")?{ts:e=>{var t=importPackage({packageName:"typescript"}),n=importPackage({packageName:"sourcemap-codec",funcName:"decode"}),[o,a,e]=extractEmbedMap(e,{decode:n}),t=t.transpile(e,{sourceMap:!0,inlineSourceMap:!0,inlineSources:!0,jsx:!0,allowJs:!0});return a?([e,o]=mergeFlatMaps(t,o,{mapStartToken:TS_MAP_Token,decode:n}),n=importPackage({packageName:"sourcemap-codec",funcName:"encode"}),a.mappings=n(o),a.file="",e+"\n"+TS_MAP_Token+Buffer.from(JSON.stringify(a)).toString("base64")):t}}:null,plugins:[].concat(minify?[{name:"neo-minify-plugin",bundle:(e,{maps:t})=>{e=importPackage({packageName:"uglify-js"}).minify({target:e},{sourceMap:sourcemap?{content:JSON.stringify(t),url:sourcemapInline?"inline":target+".map"}:void 0});return sourcemap&&!sourcemapInline&&fs.writeFileSync(target+".map",e.map),e.code}}]:[]).concat(jsx__converter?[{name:"neo-jsx-convert-plugin",bundle:(e,{maps:t})=>{var n=importPackage({packageName:"babel-standalone"}),o=importPackage({packageName:"babel-plugin-transform-react-jsx"}),n=n.transform(e,{inputSourceMap:t,sourceMaps:!0,plugins:[o]});return e=n.code+"\n"+TS_MAP_Token+Buffer.from(JSON.stringify(n.map)).toString("base64")}}]:[])});function importPackage({packageName:t,funcName:n,destDesc:o}){var e=t+"."+(n||"default");if(cache[e])return cache[e];try{var a=n?commonjsRequire(t)[n]:commonjsRequire(t)}catch(e){console.log(`[33mThe package ${t} needed ${o} has not been found and will be tried to install automatically[0m`),console.log(execSync("npm i "+t).toString());a=n?commonjsRequire(t)[n]:commonjsRequire(t)}return cache[e]=a}function resolveFile(e,t){let n=getArgv("-"+e)||(1===t?process.argv[t+1]:null);return n||(e=`the path is not specified (use the -${e} <filename> option for specify ${helpers[e]})`,console.warn("[31m"+e+"[0m"),process.exit(1)),path.isAbsolute(n)||(n=path.resolve(process.cwd(),n)),t&&void 0!==t&&!fs.existsSync(n)&&(console.log(process.cwd),console.warn("[31m"+n+" file not found[0m"),process.exit(1)),n}result&&(console.log(`[34m${source} => ${target}[0m`),sourcemap&&0==!!sourcemapInline&&console.log(`[34m${".".repeat(source.length)} => ${target}.map[0m`),~process.argv.indexOf("--time"))&&console.timeEnd("built in"),module.exports=$bin;
