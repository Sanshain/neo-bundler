#!/usr/bin/env node

"use strict";var require$$1=require("path"),require$$0=require("fs"),require$$2=require("perf_hooks"),require$$3=require("child_process");function _interopDefaultLegacy(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var require$$1__default=_interopDefaultLegacy(require$$1),require$$0__default=_interopDefaultLegacy(require$$0),require$$2__default=_interopDefaultLegacy(require$$2),require$$3__default=_interopDefaultLegacy(require$$3);function commonjsRequire(e){throw new Error('Could not dynamically require "'+e+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var __bin={},main={},utils={};function deepMergeMap$1(e,t,n){const{outsideMapInfo:a,outsideMapping:o}=t,{sourcesContent:r,files:s}=e;t=e.mapping.map(n=>n&&n.length?(n.forEach((e,t)=>{n[t][1]<s.length-1&&(n[t][1]+=a.sources.length)}),n):[]).map((r,e)=>{return r&&r.length?(r||[]).map((e,t,n)=>{t=o[r[t][2]];return t&&t.length?t[0]:e[1]>a.sources.length-1?e:null}).filter(e=>e):[]});return a.sources=a.sources.concat(s.slice(0,-1)),a.sourcesContent=a.sourcesContent.concat((r||[]).slice(0,-1)),n&&(a.mappings=n(t)),{mergedMap:t,outsideMapInfo:a}}function mergeFlatMaps$1(e,t,n){var r,a,o,{mapStartToken:n,pluginMapping:s,decode:i}=n||{},s=(s?r=s:[r,a,o]=extractEmbedMap$1(e,{sourceMapToken:n,decode:i}),r.map(e=>e?e[0]:[]).map(e=>t[e[2]]));return[o||e,s]}function extractEmbedMap$1(e,t){var n=(t||{})["sourceMapToken"],r=e.lastIndexOf(n=n||"//# sourceMappingURL=data:application/json;charset=utf-8;base64,"),n=e.slice(r+n.length),n=JSON.parse(Buffer.from(n,"base64").toString());return[t.decode(n.mappings),n,e.slice(0,r)]}utils.deepMergeMap=deepMergeMap$1,utils.mergeFlatMaps=mergeFlatMaps$1,utils.extractEmbedMap=extractEmbedMap$1;const fs$1=require$$0__default.default,path$1=require$$1__default.default,deepMergeMap=utils["deepMergeMap"],requireOptions={sameAsImport:"same as imports"};let startWrapLinesOffset=1,endWrapLinesOffset=5;const extensions=[".ts",".js"];var rootOffset=0,exportedFiles=[];let logLinesOption=!1,incrementalOption=!1;function combineContent(e,t,n,r){globalOptions=n;var a=e;return rootOffset=0,sourcemaps.splice(0,sourcemaps.length),Object.keys(modules).forEach(e=>delete modules[e]),logLinesOption=n.logStub,(incrementalOption=!!n.advanced&&n.advanced.incremental)&&(startWrapLinesOffset=3,endWrapLinesOffset=8),exportedFiles=[],n.removeLazy&&((n.sourceMaps||n.getSourceMap)&&(console.warn("[33mremoveLazy option uncompatible with sourceMap generation now. Therefore it`s passed[0m"),n.sourceMaps=null,n.getSourceMap=null),e=removeLazy(e)),e=importInsert(e,t,n),e=mapGenerate({target:n.targetFname,options:n,originContent:a,content:e}),e=n.advanced&&n.advanced.ts?n.advanced.ts(e):e}function buildFile(e,t,n){var r=fs$1.readFileSync(e).toString(),e=path$1.resolve(e),t=t||path$1.parse(e).dir+path$1.sep+path$1.parse(e).name+".js",n=Object.assign({entryPoint:path$1.basename(e),release:!1,targetFname:t},n),r=combineContent(r,path$1.dirname(e),n);return fs$1.writeFileSync(t,r),r}class PathMan{constructor(e,t){this.dirPath=e,this.getContent=t||getContent}}class Importer{constructor(e){this.namedImportsApply=namedImports,this.moduleStamp=moduleSealing,this.pathMan=e}}function mapGenerate({options:e,content:n,originContent:r,target:a,cachedMap:o}){let s=!1;if(e.getSourceMap||e.sourceMaps){var i=Object.values(modules),c=o||sourcemaps.map(e=>e.debugInfo).reduce((e,t)=>e.concat(t));if(o||c.push(null),e.getSourceMap&&e.getSourceMap({mapping:c,sourcesContent:i.map(e=>e.split("\n").slice(startWrapLinesOffset,-endWrapLinesOffset).join("\n")).concat([r]),files:sourcemaps.map(e=>e.name)}),e.sourceMaps){let t=c.map(e=>e||[]);var o=e.sourceMaps.encode(t),c=path$1&&a?path$1.basename(a):"";const p={version:3,file:c,sources:sourcemaps.map(e=>e.name),sourcesContent:i.map(e=>e.split("\n").slice(startWrapLinesOffset,-endWrapLinesOffset).join("\n")).concat([r]),names:[],mappings:o};e.sourceMaps.injectTo&&(i=e.sourceMaps.injectTo,{mergedMap:r,outsideMapInfo:o}=deepMergeMap({...p,files:p.sources,mapping:t},{outsideMapInfo:i,outsideMapping:i.maps||globalOptions.sourceMaps.decode(i.mappings)}),o.mappings=e.sourceMaps.encode(t=r),p.sources=o.sources,p.sourcesContent=o.sourcesContent),e.plugins&&(s=!0,e.plugins.forEach(e=>{e.bundle&&(n=e.bundle(n,{target:a,maps:p,rawMap:t}))})),e.sourceMaps.verbose&&console.log(p.sources,p.sourcesContent,t),fs$1&&!0===e.sourceMaps.external?(fs$1.writeFileSync(a+".map",JSON.stringify(p)),n+=`
//# sourceMappingURL=${c}.map`):(i=globalThis.document?btoa(JSON.stringify(p)):Buffer.from(JSON.stringify(p)).toString("base64"),n+=`
//# sourceMappingURL=data:application/json;charset=utf-8;base64,`+i)}}return e.plugins&&!s&&e.plugins.forEach(e=>{e.bundle&&(n=e.bundle(n,{target:a}))}),n}let globalOptions=null;function importInsert(e,t,n){var t=new PathMan(t,n.getContent||getContent),r=!(!n.sourceMaps&&!n.getSourceMap);logLinesOption&&(e=e.replace(/console.log\(/g,function(){var e=arguments[2].slice(0,arguments[1]).split("\n").length.toString();return'console.log("'+n.entryPoint+":"+e+':", '}));const a=n.sourceMaps&&n.sourceMaps.charByChar,o=(e=new Importer(t).namedImportsApply(e,void 0,n.sourceMaps&&n.sourceMaps.charByChar?1:r),e="\n\n//@modules:\n\n\n"+Object.values(modules).join("\n\n")+`


//@${n.entryPoint}: 
`+e,null);return r&&(rootOffset+=5+2*sourcemaps.length+1,sourcemaps[0]&&sourcemaps[0].debugInfo.unshift(o,o,o,o),sourcemaps.forEach(e=>{e.debugInfo.unshift(o)}),t=e.split("\n").slice(rootOffset).map((e,n)=>{return a?[[0,sourcemaps.length,n,0]]:[].map.call(e,(e,t)=>[t,sourcemaps.length,n,t])}),sourcemaps.push({name:n.entryPoint,debugInfo:[o,o,o].concat(t)})),n&&n.release&&(n.sourceMaps&&console.warn("Generate truth sourcemaps with options `release = true` is not guaranteed"),e=(e=(e=e.replace(/console.log\([\s\S]+?\)\n/g,n.sourceMaps?"\n":"")).replace(/\/\/[\s\S]*?\n/g,n.sourceMaps?"\n":"")).replace(/^[\s]*/gm,"")),e}const modules={},sourcemaps=[];function namedImports(e,m,a){const t=new Set;e=e.replace(/^import (((\{([\w, ]+)\})|([\w, ]+)|(\* as \w+)) from )?\".\/([\w\-\/]+)\"/gm,(e,t,n,r,a,o,s,i,c,p)=>{var l=((m||"")+i).replace(/\//g,"$");if(modules[l]||f.call(this,i,l),o&&d(o))return`const { default: ${o} } = $$${l}Exports;`;if(s)return`const ${s.split(" ").pop()} = $$${l}Exports;`;var u,i=a.split(",").map(e=>(~e.indexOf(" as ")?e.trim().split(" ").shift()+": "+e.trim().split(" ").pop():e).trim());for(u of i)d(u=~u.indexOf(":")?u.split(": ").pop():u);return`const { ${i.join(", ")} } = $$${l}Exports;`});return globalOptions?.advanced?.require===requireOptions.sameAsImport?(console.log("require import"),e.replace(/(?:const|var|let) \{?[ ]*(?<varnames>[\w, :]+)[ ]*\}? = require\(['"](?<filename>[\w\/\.\-]+)['"]\)/g,(e,t,n)=>{var r=((m||"")+(n=n.replace(/^\.\//m,""))).replace(/\//g,"$");if(!modules[r]&&!f.call(this,n,r))return e;return e.split("=")[0]+`= $$${r}Exports;`})):e;function f(e,t){let r=this.moduleStamp(e,m||void 0,a);return!!r&&(e=r.lines.map(([n,e],t)=>{return t>=r.lines.length-endWrapLinesOffset||t<startWrapLinesOffset?null:1===a?[].map.call(e,(e,t)=>[t,sourcemaps.length-1+1,n-startWrapLinesOffset,t]):[[0,sourcemaps.length-1+1,n-startWrapLinesOffset,1]]}),sourcemaps.push({name:t.replace(/\$/g,"/")+".js",debugInfo:e}),!0)}function d(e){if(!t.has(e))return t.add(e),1;console.warn("Duplicating the imported name")}}function moduleSealing(t,e,n){let r=this.pathMan.getContent(t);var a=((e||"")+t).replace(/\//g,"$");if(""==r)return null;var o=path$1?path$1.dirname(t):t.split("/").slice(0,-1).join("/"),e=(o="."===o?"":o,(e?e+(o?"/":""):"")+o);r=namedImports(r=logLinesOption?r.replace(/console.log\(/g,function(){var e=arguments[2].slice(0,arguments[1]).split("\n").length.toString();return'console.log("'+t+".js:"+e+':", '}):r,e);let s=Array.from(r.matchAll(/^export (class|function|let|const|var) ([\w_\n]+)?[\s]*=?[\s]*/gm)).map(e=>e[2]).join(", ");o=r.match(/^export default \b([\w_]+)\b( [\w_\$]+)?/m);return o&&(~["function","class"].indexOf(o[1])?(o[2]||(r=r.replace(/^export default \b([\w_]+)\b/m,"export default $1 $default")),s+=", default: "+(o[2]||"$default")):s+=", default: "+o[1]),s=`exports = { ${s=s.startsWith(" ,")?s.slice(2):s} };`+"\n".repeat(startWrapLinesOffset),r=r.replace(/^export (default )?/gm,"")+"\n\n"+s+"\nreturn exports",modules[a]=`const $$${a}Exports = (function (exports) {
 ${r.split("\n").join("\n\t")} 
})({})`,incrementalOption&&(modules[a]=`
/*start of ${t}*/
${modules[a]}
/*end*/

`),n?(e=modules[a].split("\n"),{fileStoreName:a,updatedRootOffset:rootOffset+=e.length,lines:e.map((e,t)=>[t,e])}):null}function getContent(e){e=path$1.normalize(this.dirPath+path$1.sep+e);for(var t of extensions)if(fs$1.existsSync(e+t)){e+=t;break}return exportedFiles.includes(e)?(console.warn(`attempting to re-import '${e}' into 'base.ts' has been rejected`),""):(exportedFiles.push(e),fs$1.readFileSync(e).toString())}function removeLazy(e){return e.replace(/\/\*@lazy\*\/[\s\S]*?\/\*_lazy\*\//,"")}main.default=main.build=main.buildContent=main.combineContent=combineContent,main.integrate=main.packFile=main.buildFile=buildFile,main.requireOptions=requireOptions;const path=require$$1__default.default,fs=require$$0__default.default,execSync=(require$$2__default.default.performance,require$$3__default.default)["execSync"],build=main.buildFile,{mergeFlatMaps,extractEmbedMap}=utils,TS_MAP_Token="//# sourceMappingURL=data:application/json;base64,",cache={};function getArgv(e){e=process.argv.indexOf(e)+1;return e?process.argv[e]:null}~process.argv.indexOf("-h")&&(console.log(`
-s 		- source file name (could be passed as first arg without the flag -s)
-t 		- target file name (required)
-m 		- generate sourcemap file 	(optional)
--time 	- verbose build time  		(optional)
    `),process.exit(0));const helpers={s:"source file",t:"target file"};let source=resolveFile("s",1),target=resolveFile("t",!1);const sourcemapInline=~process.argv.indexOf("--inline-m"),sourcemap=sourcemapInline||~process.argv.indexOf("-m"),minify=sourcemapInline||~process.argv.indexOf("--minify"),jsx__converter=sourcemapInline||~process.argv.indexOf("--jsx-converter"),release=~process.argv.indexOf("-r");release&&sourcemap&&console.log("[34m >> using the -k option in conjunction with - is not recommended, since these options have not been tested together.[0m"),console.time("built in");let result=build(source,target,{release:1==!!release,sourceMaps:sourcemap?(()=>{var t="sourcemap-codec";try{var n=commonjsRequire(t)["encode"]}catch(e){console.log("[33mThe package needed to generate the source map has not been found and will be installed automatically[0m"),console.log(execSync("npm i sourcemap-codec").toString());var n=commonjsRequire(t)["encode"]}return{encode:n,external:1==!!sourcemapInline}})():null,advanced:source.endsWith(".ts")?{ts:e=>{var t=importPackage({packageName:"typescript"}),n=importPackage({packageName:"sourcemap-codec",funcName:"decode"}),[r,a,e]=extractEmbedMap(e,{decode:n}),t=t.transpile(e,{sourceMap:!0,inlineSourceMap:!0,inlineSources:!0,jsx:!0,allowJs:!0});return a?([e,r]=mergeFlatMaps(t,r,{mapStartToken:TS_MAP_Token,decode:n}),n=importPackage({packageName:"sourcemap-codec",funcName:"encode"}),a.mappings=n(r),a.file="",e+"\n"+TS_MAP_Token+Buffer.from(JSON.stringify(a)).toString("base64")):t}}:null,plugins:[].concat(minify?[{name:"neo-minify-plugin",bundle:(e,{maps:t})=>{e=importPackage({packageName:"uglify-js"}).minify({target:e},{sourceMap:sourcemap?{content:JSON.stringify(t),url:sourcemapInline?"inline":target+".map"}:void 0});return sourcemap&&!sourcemapInline&&fs.writeFileSync(target+".map",e.map),e.code}}]:[]).concat(jsx__converter?[{name:"neo-jsx-convert-plugin",bundle:(e,{maps:t})=>{var n=importPackage({packageName:"babel-standalone"}),r=importPackage({packageName:"babel-plugin-transform-react-jsx"}),n=n.transform(e,{inputSourceMap:t,sourceMaps:!0,plugins:[r]});return e=n.code+"\n"+TS_MAP_Token+Buffer.from(JSON.stringify(n.map)).toString("base64")}}]:[])});function importPackage({packageName:t,funcName:n,destDesc:r}){var e=t+"."+(n||"default");if(cache[e])return cache[e];try{var a=n?commonjsRequire(t)[n]:commonjsRequire(t)}catch(e){console.log(`[33mThe package ${t} needed ${r} has not been found and will be tried to install automatically[0m`),console.log(execSync("npm i "+t).toString());a=n?commonjsRequire(t)[n]:commonjsRequire(t)}return cache[e]=a}function resolveFile(e,t){let n=getArgv("-"+e)||(1===t?process.argv[t+1]:null);return n||(e=`the path is not specified (use the -${e} <filename> option for specify ${helpers[e]})`,console.warn("[31m"+e+"[0m"),process.exit(1)),path.isAbsolute(n)||(n=path.resolve(process.cwd(),n)),t&&void 0!==t&&!fs.existsSync(n)&&(console.log(process.cwd),console.warn("[31m"+n+" file not found[0m"),process.exit(1)),n}result&&(console.log(`[34m${source} => ${target}[0m`),sourcemap&&0==!!sourcemapInline&&console.log(`[34m${".".repeat(source.length)} => ${target}.map[0m`),~process.argv.indexOf("--time"))&&console.timeEnd("built in"),module.exports=__bin;
